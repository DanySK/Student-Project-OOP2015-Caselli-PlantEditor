\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{enumitem}
\usepackage[italian]{babel}
\usepackage{graphicx}
\usepackage{framed}
\usepackage[labelfont=bf]{caption}
% \usepackage[figurename=Figura]{caption}
\lstset{frame=single, breaklines=true}

\title{Corso di Laurea in Ingegneria e Scienze Informatiche\\\textbf{\newline\\Planted}\\{(OOP15 - Process Report)}}
\date{\today}
\author{Ashley Caselli (\href{mailto:ashley.caselli@studio.unibo.it}{ashley.caselli@studio.unibo.it})\\Matricola 635153}

\begin{document}
  \maketitle
  \newpage
  \tableofcontents
  \newpage
  %--------------------------------------------------------------------------------------------------------------------------------------
  \section{Introduzione}
  Questo documento descrive lo sviluppo software del progetto Planted, sviluppato per il corso di Programmazione ad Oggetti.
  %--------------------------------------------------------------------------------------------------------------------------------------
  \section{Requisiti}
  L’UML è un linguaggio di modellazione basato sul paradigma ad oggetti.\\Al momento esistono diversi strumenti software per la modellazione in UML.\\
  Il sistema software Planted sarà un semplice editor di testo che permetterà all'utente di scrivere codice conforme al linguaggio usato
  dalla libreria PlantUML (http://plantuml.com/), e mediante l'integrazione con essa, supporti la visualizzazione real time del modello che si sta creando.\\
  Inoltre il sistema software dovrà permettere l'esportazione del modello in un formato grafico (es. png).\\
  Nel caso in cui si stia scrivendo un modello UML dell classi, allora il sistema software dovrà permettere all'utente non solo di esportare il modello
  in formato grafico (infatti questa funzione deve essere possibile per ogni modello), ma anche di generare codice sorgente a partire dal modello delle classi
  che si sta definendo. L'utente quindi avrà la possibilità di scegliere il linguaggio nel quale vuole che il codice sorgente sia scritto.\\
  Il sistema software inoltre dovrà rendere possibile all'utente l'import di file al suo interno e la creazione del modello UML delle classi a partire
  da codice sorgente (es: scritto in Java).
  %--------------------------------------------------------------------------------------------------------------------------------------
  \section{Analisi}
  //TODO da rivedere
  Il sistema software dovrà essere in grado di gestire progetti, al cui interno ci potranno essere più file di natura diversa (es: file che descrive il modello,
  file con codice sorgente, ecc...). Un \textbf{progetto (IProject)} è quindi un contenitore di file sorgenti che possono essere scritti in linguaggi diversi tra loro.
  Ogni progetto al suo interno potrà contenere dei file di natura diversa tra loro. All'interno dell'editor ci sarà la possibilità di creare più progetti,
  che a loro volta faranno parte dello stesso spazio di lavoro \textbf{(IWorkspace).}\\
  Un \textbf{file sorgente (ISourceFile)} presente all'interno di un progetto rappresenta perciò un file di testo con una certa estensione a seconda del linguaggio che contiene.\\
  Queste 3 entità appena descritte sono rappresentate nel modello UML sottostante:
  \begin{center}
    \includegraphics[scale=0.5]{img/IWorkspace}
    \includegraphics[scale=0.5]{img/IProject}
    \includegraphics[scale=0.5]{img/ISourceFile}
  \end{center}
  Ogni file sorgente sarà caratterizzato dal \textbf{tipo (FileType),} che rappresenterà la natura del suo contenuto e la sua estensione.
  \begin{center}
    \includegraphics[scale=0.5]{img/filetype}
  \end{center}
  Il sistema inoltre richiede la capacità di interpretare il contenuto testuale di un file per poter generare codice sorgente nel linguaggio scelto.
  Per soddisfare tale requisito sarà necessaria un'entità denominata \textbf{parser (IParser)}, che
  \begin{center}
    \includegraphics[scale=0.5]{img/IParserEmpty}
  \end{center}




  %--------------------------------------------------------------------------------------------------------------------------------------
  \section{Design}
  %--------------------------------------------------------------------------------------------------------------------------------------
  \subsection{Architettura}
  Per lo sviluppo del progetto si è scelto di utilizzare il \textit{pattern architetturale MVC}, creando una suddivisione logica dei componenti come segue:
  \begin{itemize}
    \item \textbf{Model} si occupa dei dati del sistema, in particolare fornisce funzionalità per la persistenza dei dati all'interno del sistema e fornisce
    accesso ai dati al controller.
    \item \textbf{View} si occupa di fornire all'utente la possibilità di interagire con il sistema (a livello grafico), mostrando l'editor
    di testo, l'albero dei progetti all'interno del workspace e tutte le possibili azioni che l'utente può fare (comandi che saranno passati al controller)
    con il controller.
    \item \textbf{Controller} contiene la business logic del sistema. Si occupa dell'interazione tra model e view, in particolare riceve i comandi che l'utente da al sistema
    attraverso la view e li attua, aggiornando in seguito sia model che view.
  \end{itemize}
  \begin{framed}
    \centering
    \begin{center}
      \includegraphics[scale=0.5]{img/mvc}
    \end{center}
  \end{framed}
  %--------------------------------------------------------------------------------------------------------------------------------------
  \subsubsection{Model}
  Il livello di Model fornisce accesso ai dati del sistema alla business logic, che è rappresentata dal livello denominato Controller.\\
  I dati presenti all'interno del sistema sono definiti dal seguente modello dei dati:
  \begin{framed}
    \centering
    \textbf{Data Model}
    \begin{center}
      \includegraphics[scale=0.5]{img/datamodel}
    \end{center}
  \end{framed}
  Come si può notare dal modello dei dati viene utilizzato il \textit{pattern bridge} per separare l'entità ISourceEntity dalla sua concreta
  implementazione (ISourceEntutyImpl). Questo permette di avere una maggiore libertà nel caso in cui si volessero aggiungere funzionalità
  al sistema in futuro.\\
  \\L'entità \textbf{IModel} rappresenta il punto di accesso al livello di Model per la business logic. Essa rappresenta quindi il vero e
  proprio livello di Model del sistema. Le funzionalità che essa fornisce sono descritte di seguito:
  \begin{center}
    \includegraphics[scale=0.5]{img/IModel}
  \end{center}
  %--------------------------------------------------------------------------------------------------------------------------------------
  \subsubsection{View}
  Il livello di View è ciò che l'utente vede e con il quale può interagire per inviare comandi al resto del sistema.\\
  L'entità \textbf{IView} rappresenta questo livello, e fornisce le funzionalità sotto descritte per interagire con esso:
  \begin{center}
    \includegraphics[scale=0.5]{img/IView}
  \end{center}
  %--------------------------------------------------------------------------------------------------------------------------------------
  \subsubsection{Controller}
  Il livello Controller è il vero e proprio core del sistema. Esso rappresenta la business logic del sistema, ciò che collega tra loro i due livelli
  sopra citati: Model e View.\\
  L'entità che rappresenta tale livello è chiamata IController:
  \begin{center}
    \includegraphics[scale=0.5]{img/IController}
  \end{center}
  Tutta la logica dell'applicazione sarà incapsulata nel componente che implementerà l'interfaccia di IController. In questo modo la logica del sistema
  rimane indipendente dal modello dei dati (Model) e dalla loro rappresentazione dei dati (View).
  %---------------------------------------------------------------------------------------------------------------------------------------------------------------
  \subsubsection{Interazione dei livelli logici}
  In questa sezione saranno descritte le funzionalità del sistema attraverso alcuni diagrammi di interazione, in particolare il modo con cui i tre livelli descritti
  in precedenza interagiscono tra loro.\\
  La modalità di interazione tra i tre livelli è la seguente:
  \begin{center}
    \includegraphics[scale=0.8]{img/MVCinteraction}
  \end{center}
  La comunicazione tra il livello View ed il livello Controller avviene attraverso il \textit{pattern observer.} In particolare il Controller agisce
  da osservatore e la View da sorgente di eventi.\\
  \\Come si può notare dal diagramma sottostante le due entità Controller e View implementano rispettivamente l'interfaccia ICommandObserver ed ICommandObservable
  che a loro volta implementano le interfacce IObservable ed IObserver.
  \begin{center}
    \includegraphics[scale=0.6]{img/pattern-observer}
  \end{center}
  Le due interfacce ICommandObserver ed ICommandObservable rappresentano due entità in grado di inviare ed ascoltare comandi, ed interagiscono tra
  loro tramite il pattern observer. L'interazione tra loro è alla base dell'interazione che c'è tra View e Controller.
  \begin{center}
    \includegraphics[scale=0.6]{img/execCommand}
  \end{center}
  %--------------------------------------------------------------------------------------------------------------------------------------------------------------
  \subsubsection{Parser}
  Il sistema software deve possedere inoltre una funzionalità che permette di generare automaticamente il codice sorgente Java a partire dal modello UML delle
  classi e viceversa. Per soddisfare questa funzionalità c'è la necessità di avere all'interno del sistema un'entità in grado di prendere in input uno stream di dati
  e fornire in output un diverso stream di dati ma strettamente correlato a quello fornitogli in ingresso. Questà entità deve quindi essere in grado fare
  un'analisi lessicale e sintattica dello stream passatogli in input, e fornire in output uno stream conforme lessicalmente e sintatticamente a ciò che viene
  richiesto (sia esso codice Java o codice per la libreria PlantUML).\\
  Il comportamento descritto sopra viene detto \textit{parsing,} ovvero l'insieme dell'analisi lessicale ed analisi sintattica di uno stream di dati.\\
  \\L'entità che ha il compito di effettuare il parsing è chiamata \textbf{IParser.}
  \begin{center}
    \includegraphics[scale=0.6]{img/IParser}
  \end{center}
  %-------------------------------------------------------------------------------------------------------------------------------------------------------------
  \subsection{Design Dettagliato}
  Il sistema è suddiviso in package, ognuno dei quali conterrà una parte di sistema.\\
  Ogni package avrà al suo interno tutto ciò che si occupa della parte del sistema per cui è stato pensato.
  \\Il primo package descritto è chiamato \textbf{interfaces}. Al suo interno si trovano le interfacce delle entità che compongono il modello del dominio. Queste
  interfacce sono scritte nel linguaggio che si sceglierà per lo sviluppo del sistema software e dipendono esclusivamente dal meta modello creato per il sistema (per esempio
  attraverso i diagrammi UML). Al suo interno non ci deve essere nessuna implementazione e logica del sistema.\\
  La logica del sistema è contenuta nel package definito \textbf{controller,} che conterrà esclusivamente la business logic.\\
  Il del package \textbf{model} è stato pensato per contenere le implementazioni delle entità del modello del dominio che riguardano il livello logico di Model
  dell'architettura MVC. È bene suddividere i compiti del sistema, ed anche i package in modo che salti subito all'occhio di quale livello un'entità fa parte.\\
  Per contenere il livello di View è stato creato il package \textbf{gui.}
  \begin{framed}
    \centering
    \begin{center}
      \textbf{MVC - Packages}\par\medskip
      \includegraphics[scale=0.6]{img/MVCPackage}
    \end{center}
  \end{framed}
  Inoltre sono stati definiti ulteriori package per avere una maggiore suddivisione logica della componenti del sistema. Per questo motivo sono stati creati i package
  \textbf{parser}, \textbf{parser.listener} e \textbf{parser.printer} che, come si può intuire dal nome, conterranno tutto ciò che riguarda la funzionalità di parsing.
  Infine sono stati definiti altri package utili alla realizazzione finale del sistema: il package \textbf{utils} che conterrà al suo interno le utilità del sistema
  e le impostazioni; il package \textbf{exception}, al cui interno si troveranno le del sistema; ed il package \textbf{filefilter} che sarà utile per la gestione dei file
  di progetto.
  \begin{framed}
    \centering
    \begin{center}
      % \textbf{MVC - Packages}\par\medskip
      \includegraphics[scale=0.6]{img/generalPackages}
    \end{center}
  \end{framed}
  %-------------------------------------------------------------------------------------------------------------------------------------------------------------
  \section{Sviluppo}
  La fase di sviluppo del sistema software richiede innanzitutto di scegliere il linguaggio di programmazione con il quale verrà scritto il codice. In questo caso, essendo questo progetto
  sviluppato per l'esame di OOP, sarà usato (Java - versione 8).\\
  Questa fase deve iniziare tassativamente solo dopo che si sono ultimate le fasi di analisi (dei requisiti e del problema) e si è definito il design del sistema, definendo quindi
  il modello del dominio.\\
  \\L'utilizzo di Java mi ha portato a basare lo sviluppo del progetto su Maven, un gestore di progetti Java e build automation. In questo modo l'implementazione del progetto non dipenderà da nessun IDE (in questo caso
  è viene usato Eclipse), ma solo ed esclusivamente dai file di configurazione di Maven.\\
  Quando si è in questa fase si inizia sempre col creare le implementazioni delle entità che definiscono il modello del dominio ed i loro relativi Unit Test. Seguendo questa politica, ho successivamente
  implementato tutte le componenti essenziali per l'architettura MVC in modo da avere un core dell'applicazione pronto per essere ampliato con le relative funzionalità.\\
  Implementare le componenti essenziali per l'architettura MVC consiste nello scrivere una prima, anche se scarna, business logic del sistema, che sarà in seguito ampliata per soddisfare tutte le funzionalità
  che il sistema deve avere. Per fare ciò bisogna definire un comportamento per ogni metodo che si era definito nel modello del Controller.\\
  \\Molto importante nello sviluppo è la creazione di classi di supporto e per le configurazioni del sistema. In questo modo risulta più semplice
  la manutenzione e c'è una maggior divisione logica dei compiti. In particolare ho creato una classe, chiamata \textbf{SysKB}, che ha come unico scopo il raccoglimento
  di tutti quei parametri usati nel sistema come predefiniti ma che possono essere oggetto di future modifiche non preventivate in questo progetto (es. path
  delle cartelle dove si serializzano i dati). Oltre alla buona organizzazione ed alla facile manutenzione, questo permette anche di estendere alcune funzionalità
  del sistema e modificarle senza dover modificare tutto il core di esso.
  %-------------------------------------------------------------------------------------------------------------------------------------------------------------
  \subsection{Parsing}
  La funzionalità di Parsing richiesta per lo soddisfacimento del requisito del sistema può essere sviluppata in più modi.\\Il primo modo, nonchè il più
  semplice da costruire senza avere nessuna conoscenza avanzata sulla costruzione di un parser, è quello di costruire alcune classi che fungono da riconoscitori di
  grammatica e "convertitori" di ciò che stanno leggendo verso un nuovo stream di dati il cui contenuto dovrà essere conforme al linguaggio richiesto. In questo
  modo ho costruito due classi in grado di prendere in ingresso uno stream di dati (ed il tipo del file, che indica il modo in cui va interpretato lo stream),
  analizzarne il contenuto e creare uno stream di dati in uscita che conterrà lo stream di dati preso in ingresso e convertito verso un linguaggio scelto.
  \begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{img/firstParser}
  \end{figure}
  In questo modo se si vogliono aggiungere uno o più linguaggi a quelli che il sistema è già in grado di parserizzare, l'unica cosa da fare è creare una classe
  che estende l'interfaccia \textbf{IParser} ed al suo interno costruire un riconoscitore per la grammatica usata dal linguaggio che si vuole aggiungere.\\
  \\La costruzione di un riconoscitore di  grammatica in questo modo però ha molti limiti, che si evidenziano all'aumentare dei possibili token che la grammatica
  utilizza. Per questo motivo (e non solo) ho deciso di sviluppare la funzionalità di Parsing attraverso l'utilizzo di un generatore di parser, e dopo essermi
  documentato su come si costruisce un "vero" parser ho optato per l'utilizzo di ANTLR v4.
  %-------------------------------------------------------------------------------------------------------------------------------------------------------------
  \subsubsection{ANTLR v4 - Grammatiche}
  ANTLR è un generatore di parser per leggere, processare e/o tradurre testo strutturato. Il suo funzionamento si basa sulla definizione di una grammatica, ed a partire
  da essa il tool genera le classi necessarie (lexer, parser, listener) per eseguire le varie operazioni.\\
  \\Utilizzando questo tool (esiste l'integrazione per quasi ogni IDE) ho scritto due grammatiche:
  \begin{itemize}
    \item \textbf{Plant} grammatica di base per il linguaggio usato dalla libreria PlantUML
      \begin{lstlisting}
        grammar Plant;

        // Parser Rules

        plantDeclaration : '@startuml' classDeclaration* '@enduml';
        classDeclaration : 'class' TEXT classBody;
        classBody : '{' classBodyDeclaration* '}';
        classBodyDeclaration: fieldDeclaration | methodDeclaration ;
        fieldDeclaration : modifierDeclaration? nameDeclaration ':' typeDeclaration;
        methodDeclaration: modifierDeclaration? returnTypeMethodDeclaration? methodNameDeclaration paramDeclaration  ;
        returnTypeMethodDeclaration: 'int' | 'String' | 'void';
        paramDeclaration: '(' paramBodyDeclaration* ')';
        firstParamBodyDeclaration: typeParamDeclaration TEXT;
        paramBodyDeclaration: firstParamBodyDeclaration otherParamBodyDeclaration*;
        otherParamBodyDeclaration: ',' typeParamDeclaration TEXT;
        typeParamDeclaration: 'int' | 'String';
        typeDeclaration: 'int' | 'String';
        modifierDeclaration :  MODIFIER;
        nameDeclaration : TEXT;
        methodNameDeclaration : TEXT;

        // Lexer Rules

        TEXT : ('a'..'z' | 'A'..'Z')+ ;
        MODIFIER : '+' | '-' | '~' | '#';
        WHITESPACE : ( '\t' | ' ' | '\r' | '\n'| '\u000C' )+ -> skip ;
      \end{lstlisting}
    \item \textbf{SimpleJava} grammatica di base per Java
      \begin{lstlisting}
        grammar SimpleJava;

        // Parser Rules

        classDeclaration : modifier 'class' TEXT classBody;
        classBody: '{' classBodyDeclaration* '}';
        classBodyDeclaration: fieldDeclaration | methodDeclaration;
        methodDeclaration: modifier? methodReturnType methodName paramDeclaration methodBodyDeclaration;
        methodName: TEXT;
        methodBodyDeclaration: '{' methodBody '}';
        methodBody: ((TEXT | '.' | '=')* ';')*;
        paramDeclaration:'(' paramBodyDeclaration* ')';
        paramBodyDeclaration: firstParamBodyDeclaration otherParamBodyDeclaration*;
        firstParamBodyDeclaration: paramType paramName;
        otherParamBodyDeclaration: ',' paramType paramName;
        paramName : TEXT;
        fieldDeclaration: modifier? fieldType fieldName fieldInitializion? ';';
        fieldInitializion: '=' TEXT;
        fieldName: TEXT;
        modifier
          :	'public'
          |	'protected'
          |	'private'
          ;
        methodReturnType: 'void' | type;
        type: 'int' | 'String' | 'boolean';
        fieldType: type;
        paramType: type;

        // Lexer Rules

        TEXT : ('a'..'z' | 'A'..'Z')+ ;
        WHITESPACE : ( '\t' | ' ' | '\r' | '\n'| '\u000C' )+ -> skip ;
      \end{lstlisting}
  \end{itemize}
  A partire da queste grammatiche ho utilizzato il tool per generare il necessario per utilizzare il parser attraverso i listener.





  %-------------------------------------------------------------------------------------------------------------------------------------------------------------
  \subsection{Note di Sviluppo}
  %-------------------------------------------------------------------------------------------------------------------------------------------------------------
  \section{Conclusioni}
  %-------------------------------------------------------------------------------------------------------------------------------------------------------------
\end{document}
